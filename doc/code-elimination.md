## Unused code elimination

Слой unused code elimination (далее UCE) - подсистема транспилятора, позволяющая убирать ненужные переменные и функции из генерируемого кода.

### Зачем, почему

Основные причины появления UCE:
- В определенных случаях мы должны вырезать кусок кода, поскольку его нельзя (или не нужно) транспилировать.
  - Пример: навешивание функции-обработчика onclick через jsx не должно попасть в серверный код.
- Линтер и kphp не одобряют наличия неиспользуемых переменных в коде.

Главная сложность: переменные и функции могут зависеть друг от друга и при удалении целевого использования одной функции, по цепочке неиспользуемыми могут стать другие переменные и функции... и так далее. 

### Основные понятия

- Scope - область видимости переменных и функций. Мы используем функциональную область видимости (т.е. ограниченную определениями функций).
- Child scope - дочерняя область видимости, которая может быть порождена при входе в определение функции. Имеет доступ ко всем идентификаторам верхних областей видимости.
- ScopeNode - узел, содержащий определение (declaration) функции или переменной. Может ссылаться на другие ScopeNode-ы в случае, если вычисление его значения зависит от значений других нод (т.е. одна нода необходима для другой).
- BoundNode и BindPendingNode - виды ScopeNode, отличающиеся только тем, произошло ли уже определение переменной/функции (BoundNode) или еще нет (BindPendingNode). Второй вид полезен для рекурсии и разруливания hoisting-ов, когда технически по коду переменная может быть использована раньше, чем будет определена.
- Terminal nodes - особые ScopeNode, привязанные к глобальной и к текущей областям видимости. Рассмотрим подробнее каждый из них:
  - Local terminal node - "выходная" нода текущей области видимости (можно представлять ее себе как некое виртуальное return value текущей функции, даже если фактически функция ничего не возвращает). Для каждой области видимости существует собственная Local terminal node.
  - Global terminal node - то же самое, но для глобальной области видимости (можно представить ее себе как некий виртуальный module.exports, даже если модуль фактически ничего не экспортирует). В каждой области видимости существует ссылка на Global terminal node и везде это один и тот же объект.

### Как происходит удаление кода

Связь между нодами образует направленный граф. Заметим, что в общем случае его нельзя считать ациклическим (из-за рекурсий, например). 

Подсистема UCE достаточно тесно вплетена в механизмы транспилятора, в частности это из-за нее нам требуется не один проходит по ast-дереву, а два.
- В первый проход мы заполняем кэши и собираем данные о том, какие сущности используют друг друга (так называемый dry run), получая некоторый направленный граф.
- Между проходами мы запускаем обход графа и помечаем те его ноды, которые необходимы для вычисления значений всех необходимых переменных и функций.
- Во второй проход мы генерируем код в том числе на основе полученного графа, отбрасывая те идентификаторы, для которых соответствующая вершина графа не помечена.

При заполнении графа могут возникать нюансы:
- Чем отличаются вызовы функций с присваиванием и без него, с аргументами и без них?
  - `const a = foo()` - в этом случае local terminal node функции `foo` будет присоединен к ноде `a`.
  - `foo()` - в этом случае local terminal node функции `foo` будет присоединен к local terminal node текущей области видимости.
  - `const a = foo(c, d)` - в этом случае local terminal node функции `foo`, а также ноды ее аргументов `c` и `d`, будут присоединены к ноде `a`.
  - `const a = foo(bar(), c)` - в этом случае local terminal node функции `foo`, нода ее аргумента `c`, а также local terminal node функции `bar` , будут присоединены к ноде `a`.
- Что если переменная использована до ее определения?
  - В этом случае мы используем BindPendingNode в качестве замены, указывая явно какие другие ноды зависят от ее значения
  - Когда встречается определение переменной, мы всегда вначале проверяем, нет ли уже инициализированной "висящей" ноды. Если она есть - мы ее преобразовываем в полноценную BoundNode и обновляем все связи с другими нодами.
- Как обозначить вызов по цепочке (одну из определения другой) нескольких функций, которые не возвращают ничего (а-ля процедуры)?
  - Local terminal node внешней функции нужно сделать зависимой от local terminal node вызываемой функции.
  - Аналогичным образом это работает и при вызове функций в глобальной области - за счет того, что в глобальной области Global terminal node и Local terminal node - это один и тот же объект.
- Как обработать rest/spread-операторы?
  - В случае присваивания в единственный идентификатор или из него, ничего кардинально не меняется - в граф добавляется зависимость переменной от некоторого набора переменных, или обратно
  - В случае переметров функции мы вынуждены создать фиктивную ноду для разыменовывания параметров, ее и используем.
  - Поддержка ограничена только целостным оператором, т.е. в теории можно обмануть UCE конструкцией вида `const [a, b] = [c, d]` - даже если переменная `a` не используется и будет удалена, но при этом переменная `b` используется, у нее все равно прописана зависимость от обеих переменных `c` и `d`, таким образом переменная `c` не будет удалена, даже если это ее единственное использование. 

Обход графа идет в глубину и начинается с Global terminal node. Глобальные объекты, подлежащие транспиляции (например, console - в библиотеке предусмотрен простой полифилл), должны быть заранее добавлены в глобальную область при ее порождении. 

### Побочные эффекты

Подсистема UCE или ее части задействованы также в сборе списка переменных для передачи его в замыкание (т.к. в php нужно явно указывать передаваемые переменные).